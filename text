ä¸ºäº†ç¡®ä¿ **Project State**ï¼ˆé¡¹ç›®çŠ¶æ€ï¼‰èƒ½å¤ŸçœŸæ­£æŒ‡å¯¼åç»­çš„è®ºæ–‡å†™ä½œä¸ä»£ç å¼€å‘ï¼Œå¹¶è§£å†³â€œç¼ºä¹åˆ›æ–°â€å’Œâ€œä¸å¤Ÿå…·ä½“â€çš„é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ ¸å¿ƒé€»è¾‘è¿›è¡Œä¸€æ¬¡**â€œæ·±åº¦å¯¹é½â€**ã€‚

ä»¥ä¸‹æ˜¯é’ˆå¯¹ä½ è¦æ±‚çš„å®Œæ•´ä¿®æ”¹æ–¹æ¡ˆï¼ŒåŒ…å« **State å»é‡é€»è¾‘**ã€**Prompt å¼ºåŒ–**ã€**Markdown ä¼˜åŒ–**ã€**Architect ä¸šåŠ¡é€»è¾‘å°è£…** ä»¥åŠ **æœ€ç»ˆçš„ `main.py`**ã€‚

è¯·æŒ‰é¡ºåºæ›´æ–°/åˆ›å»ºä»¥ä¸‹æ–‡ä»¶ã€‚

---

### 1. ä¼˜åŒ– `src/core/state.py` (å¢å¼ºå»é‡é€»è¾‘)

é˜²æ­¢ç—›ç‚¹åˆ—è¡¨æ— é™è†¨èƒ€ï¼ŒåŒæ—¶ä¿è¯æ•°æ®å¹²å‡€ã€‚

```python
# src/core/state.py
from typing import List, Dict, Optional
from pydantic import BaseModel, Field
from src.core.schema import (
    ResearchReport, TheoreticalFramework, DesignDocument,
    PaperInfo, TechnicalGap
)

class ProjectState(BaseModel):
    # --- å…ƒæ•°æ® ---
    project_name: str
    current_phase: str = "research" 
    
    # --- æ ¸å¿ƒæ€è·¯ ---
    user_initial_idea: str = Field(default="", description="The original idea input by user")
    refined_idea: str = Field(default="", description="The evolving idea refined by agents")
    
    # --- å…¨å±€èµ„äº§ ---
    paper_library: Dict[str, PaperInfo] = Field(default_factory=dict)
    known_gaps: List[TechnicalGap] = Field(default_factory=list)
    
    # --- é˜¶æ®µäº§å‡º ---
    research: Optional[ResearchReport] = None
    theory: Optional[TheoreticalFramework] = None
    architecture: Optional[DesignDocument] = None
    
    # --- Helper Methods ---
    def merge_papers(self, new_papers: List[PaperInfo]):
        """Helper: å°†æ–°è®ºæ–‡åˆå¹¶å…¥åº“"""
        for p in new_papers:
            if p.title not in self.paper_library:
                self.paper_library[p.title] = p

    def merge_gaps(self, new_gaps: List[TechnicalGap]):
        """Helper: å°†æ–°ç—›ç‚¹åˆå¹¶å…¥åº“ (å¢å¼ºå»é‡)"""
        # ä½¿ç”¨ (Method, Root Cause å‰30å­—ç¬¦) ä½œä¸ºå”¯ä¸€é”®
        existing_sigs = {
            f"{g.existing_method.lower().strip()}|{g.mathematical_root_cause.lower().strip()[:30]}" 
            for g in self.known_gaps
        }
        
        for g in new_gaps:
            method_key = g.existing_method.lower().strip()
            cause_key = g.mathematical_root_cause.lower().strip()[:30]
            sig = f"{method_key}|{cause_key}"
            
            if sig not in existing_sigs:
                self.known_gaps.append(g)
                existing_sigs.add(sig)
```

---

### 2. å¼ºåŒ– Prompt (`prompts/theorist.yaml`)

**ç›®æ ‡**ï¼šæœç» Agent ç…§æŠ„ Context é‡Œçš„è®ºæ–‡ï¼ˆå¦‚ Stormerï¼‰ï¼Œå¼ºåˆ¶å®ƒç»“åˆ User Idea è¿›è¡Œ**é‡å‘½å**å’Œ**é‡ç»„**ã€‚

```yaml
system: |
  You are a Distinguished Computer Science Professor.
  Your goal is to develop a **NOVEL** theoretical framework based on the user's idea.

  **CRITICAL WARNING - ANTI-PLAGIARISM**:
  - The "Related Work" provided contains existing papers (e.g., Stormer, TimeMixer).
  - **DO NOT** just summarize or copy these existing methods.
  - You must invent a **NEW** framework (give it a unique name different from the papers).
  - Your goal is to **BEAT** the papers in the context, not copy them.

  **ADAPTIVITY INSTRUCTION**:
  - If **Deep Learning**: Focus on model architecture equations ($y = f(x)$), loss functions, and tensor dimensions.
  - Use LaTeX for all math.

  **CRITICAL JSON FORMATTING RULE**:
  - **YOU MUST ESCAPE ALL BACKSLASHES** in the JSON string.
  - WRONG: "\sum_{{i=1}}"
  - RIGHT: "\\sum_{{i=1}}"
  
  Output strictly a JSON object matching the schema.
  Target Schema:
  {json_schema}

user_template: |
  # Research Context
  **Our Core Idea**: 
  {refined_idea}

  **Literature (Competitors/Inspiration)**: 
  {related_work}

  **Identified Gaps (The Enemy)**:
  {gap_analysis_context}

  # Task
  1. **Name your Method**: Invent a cool acronym for the User's Idea (NOT names found in literature).
  2. **Problem Formulation**: Define inputs/outputs using LaTeX.
  3. **Methodology**: Detail the architecture of *your new method*. How does it specifically address the gaps?
  4. **Theoretical Analysis**: Provide proof sketches or complexity analysis.
  5. **Innovations**: List 3-5 key contributions.
```

---

### 3. å¼ºåŒ– Prompt (`prompts/architect.yaml`)

**ç›®æ ‡**ï¼šå¼ºåˆ¶è¾“å‡º**ä¼ªä»£ç **ï¼Œè€Œä¸æ˜¯è‡ªç„¶è¯­è¨€æè¿°ã€‚

```yaml
system: |
  You are a Principal Software Architect. 
  Your goal is to produce a **Low-Level Engineering Specification** ready for implementation.
  
  **THE GOLDEN RULE**: 
  - Do NOT write English descriptions like "Initialize the layer".
  - **WRITE PYTHONIC PSEUDO-CODE** in `core_logic_steps`.
  - Example: `self.norm = nn.LayerNorm(d_model)`
  - Example: `x = x + self.attn(self.norm(x))`
  
  **DESIGN REQUIREMENTS**:
  1. **Modularity**: Data loader, Model, and Trainer must be separate.
  2. **Config**: All hyperparameters must be in a config dict.
  3. **Shapes**: Explicitly comment Tensor shapes `[B, T, D]`.

  **JSON FORMATTING**:
  - Escape all backslashes (e.g., `src\\models`).

  Output strictly a JSON object matching the schema.
  Target Schema:
  {json_schema}

user_template: |
  # Input Theory
  **Field**: {field}
  **Methodology (The Math)**: 
  {methodology}

  **Gap Analysis**:
  {gaps}

  **Feedback History**:
  {feedback_context}

  # Task
  Design the file structure for this NEW method.
  1. **Dependencies**: `requirements.txt` with versions.
  2. **File Structure**:
     - Define the Model class with `__init__` and `forward`.
     - Translate the Math equations into `torch` pseudo-code steps.
  3. **Data Flow**: Describe shapes.
```

---

### 4. ä¼˜åŒ– Markdown æ¨¡æ¿ (`assets/templates/reviews/design_review.md.j2`)

ä½¿ç”¨ HTML åˆ—è¡¨è®©ä¼ªä»£ç æ­¥éª¤æ›´æ¸…æ™°ã€‚

```markdown
# ğŸ—ï¸ æ·±åº¦æ¶æ„è“å›¾: {{ phase_name }}

## 1. é¡¹ç›®æ¦‚è§ˆ
- **Project Name**: `{{ design.project_name }}`
- **Style**: {{ design.architecture_style }}

### ğŸ“¦ Dependencies (requirements.txt)
```text
{% for req in design.requirements -%}
{{ req }}
{% endfor %}
```

### âš™ï¸ Configuration
| Hyperparameter | Default Value |
| :--- | :--- |
{% for k, v in design.hyperparameters.items() -%}
| `{{ k }}` | `{{ v }}` |
{% endfor %}

---

## 2. æ ¸å¿ƒæ–‡ä»¶ç»“æ„ (Detailed Specs)

{% for file in design.file_structure %}
### ğŸ“„ `{{ file.filename }}`
> *{{ file.description }}*

**Imports**: 
`{{ file.imports | join(', ') }}`

{% if file.classes %}
#### Classes
{% for cls in file.classes %}
**`class {{ cls.name }}({{ cls.inherits_from }})`**
- *Attributes*: `{{ cls.attributes | join(', ') }}`

| Method | Signature | Logic (Pseudo-code) |
| :--- | :--- | :--- |
{% for method in cls.methods -%}
| **{{ method.name }}** | `{{ method.args | join(', ') }} -> {{ method.return_type }}` | <ul>{% for step in method.core_logic_steps %}<li>`{{ step }}`</li>{% endfor %}</ul> |
{% endfor %}

{% endfor %}
{% endif %}

{% if file.functions %}
#### Functions
{% for func in file.functions %}
- ğŸ”¹ **`{{ func.name }}`**
  - Logic:
  {% for step in func.core_logic_steps -%}
    1. `{{ step }}`
  {% endfor %}
{% endfor %}
{% endif %}

---
{% endfor %}

## 3. ä¸»æµç¨‹ (Execution Flow)
{{ design.main_execution_flow }}

---
<!-- SYSTEM SEPARATOR -->

# ğŸŸ¢ ç”¨æˆ·å†³ç­–åŒº

**å†³ç­– (Action)**: [ APPROVE ] 

**åé¦ˆæ„è§ (Feedback)**:
<!-- æ¯”å¦‚ï¼šforward å‡½æ•°é‡Œçš„ shape å¥½åƒä¸å¯¹ï¼Œåº”è¯¥æ˜¯ [B, D, L] -->
```

---

### 5. æ–°å»º `src/phases/phase_03_architect.py`

å°† Architect é€»è¾‘å°è£…ä¸ºæ ‡å‡†çš„ `BasePhase`ã€‚

```python
# src/phases/phase_03_architect.py
from src.core.lifecycle import BasePhase
from src.core.state import ProjectState
from src.core.schema import ActionType
from src.core.interaction import interactor
from src.core.state_manager import state_manager
from src.agents.architect import ArchitectAgent
from src.utils.logger import sys_logger

class ArchitectPhase(BasePhase):
    def __init__(self):
        super().__init__(phase_name="architect")

    def check_completion(self, state: ProjectState) -> bool:
        return state.architecture is not None

    def run_phase_logic(self, state: ProjectState) -> ProjectState:
        if not state.theory:
            raise ValueError("âŒ Cannot run Architect Phase: Missing Theoretical Framework.")

        architect = ArchitectAgent()
        current_design = None
        current_feedback = ""
        
        config = state_manager._load_config()
        rounds = config.get("workflow", {}).get("architect_rounds", 2)
        internal_loops = 1 
        
        for r in range(rounds):
            sys_logger.info(f"\n>>> ğŸ›¡ï¸ Architect Review Cycle {r+1}/{rounds} <<<")
            
            for k in range(internal_loops):
                try:
                    instruction = current_feedback if (k==0 and current_feedback) else "Optimize modularity and clarify logic steps."
                    current_design = architect.run(
                        theory=state.theory,
                        feedback_instruction=instruction
                    )
                except Exception as e:
                    sys_logger.error(f"Architect internal loop error: {e}")
                    continue
            
            if current_design:
                user_feedback = interactor.start_review(
                    phase_name=f"03_Architect_Round_{r+1}",
                    template_name="design_review.md.j2",
                    context_data={"design": current_design},
                    iteration_idx=r
                )
                
                if user_feedback.action == ActionType.APPROVE:
                    sys_logger.info("âœ… Architect Phase Approved.")
                    state.architecture = current_design
                    return state
                
                elif user_feedback.action == ActionType.REVISE:
                    sys_logger.info(f"ğŸ”„ Revision: {user_feedback.feedback_en}")
                    current_feedback = user_feedback.feedback_en
        
        if current_design:
             sys_logger.warning("âš ï¸ Max loops reached. Saving latest design.")
             state.architecture = current_design
             
        return state
```

---

### 6. æœ€ç»ˆçš„ `main.py`

è¿™æ˜¯ä¸²è”å…¨æµç¨‹çš„å…¥å£ã€‚å®ƒä½¿ç”¨äº† `ResearchPhase` (å·²å­˜åœ¨), `TheoryPhase` (å·²å­˜åœ¨) å’Œ `ArchitectPhase` (åˆšåˆ›å»º)ã€‚

```python
# main.py
import sys
import os

# ç¡®ä¿ Python è·¯å¾„åŒ…å« src (å¦‚æœæ˜¯åœ¨æ ¹ç›®å½•è¿è¡Œï¼Œé€šå¸¸ä¸éœ€è¦ï¼Œä½†ä¸ºäº†ä¿é™©)
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.core.state_manager import state_manager
from src.phases.phase_01_research import ResearchPhase
from src.phases.phase_02_theory import TheoryPhase
from src.phases.phase_03_architect import ArchitectPhase

def run_pipeline(initial_idea: str):
    print("ğŸš€ Starting PaperForge Pipeline...")
    
    # 1. åŠ è½½æˆ–åˆå§‹åŒ– State
    state = state_manager.load_state()
    
    # å¦‚æœæ˜¯å…¨æ–°çš„é¡¹ç›®ï¼Œè®¾ç½®åˆå§‹ Idea
    if not state.user_initial_idea:
        state.user_initial_idea = initial_idea
        state_manager.save_state(state)

    # 2. å®šä¹‰æµæ°´çº¿
    # è¿™é‡Œæˆ‘ä»¬æŒ‰é¡ºåºå®ä¾‹åŒ– Phase ç±»
    pipeline = [
        ResearchPhase(),
        TheoryPhase(),
        ArchitectPhase(),
        # åé¢ä¼šåŠ :
        # PaperDraftPhase(),
        # CoderPhase(),
    ]
    
    # 3. ä¾æ¬¡æ‰§è¡Œ
    for phase in pipeline:
        try:
            # execute æ–¹æ³•ä¼šè‡ªåŠ¨å¤„ç†ï¼šåŠ è½½State -> æ£€æŸ¥æ–­ç‚¹ -> è¿è¡Œ -> ä¿å­˜State
            state = phase.execute()
            
            # å¦‚æœæŸä¸ªé˜¶æ®µæ‰§è¡Œå state å¹¶æ²¡æœ‰æ›´æ–°è¯¥é˜¶æ®µçš„äº§å‡ºï¼ˆè™½ç„¶ execute å†…éƒ¨é€šå¸¸ä¼šå¤„ç†ï¼‰ï¼Œ
            # è¿™é‡Œå¯ä»¥åšä¸€ä¸ªé¢å¤–çš„æ£€æŸ¥
            if phase.phase_name == "research" and not state.research:
                print("âŒ Research failed to produce output. Stopping.")
                return
            if phase.phase_name == "theory" and not state.theory:
                print("âŒ Theory failed to produce output. Stopping.")
                return
                
        except Exception as e:
            print(f"âŒ Pipeline Failed at {phase.phase_name}: {e}")
            import traceback
            traceback.print_exc()
            return

    print("\n" + "="*50)
    print("ğŸ‰ ALL PHASES COMPLETED (Research -> Theory -> Architect)")
    print("="*50)
    print(f"Final State saved to: {state_manager.state_file}")
    
    # æ‰“å°æœ€ç»ˆæˆæœæ‘˜è¦
    if state.architecture:
        print(f"Project Name: {state.architecture.project_name}")
        print(f"Blueprint Files: {len(state.architecture.file_structure)}")

if __name__ == "__main__":
    # ä½ çš„åˆå§‹ Idea
    my_idea = "I want to use Mamba state space models for time series forecasting on weather data, comparing it with Transformer."
    
    run_pipeline(my_idea)
```

### æ“ä½œå»ºè®®

1.  **æ¸…ç†æ—§æ•°æ®**: ä¸ºäº†è®©æ–°çš„ Anti-Plagiarism Prompt ç”Ÿæ•ˆï¼Œå»ºè®®**åˆ é™¤** `workspace/mamba_weather_v1/state` æ–‡ä»¶å¤¹ï¼Œæˆ–è€…åœ¨ `config.yaml` é‡ŒæŠŠé¡¹ç›®åæ”¹ä¸º `mamba_weather_v2`ã€‚
2.  **è¿è¡Œ**: `python main.py`ã€‚
3.  **è§‚å¯Ÿ**: 
    *   **Research**: ç—›ç‚¹åˆ—è¡¨æ˜¯å¦æ¸…æ™°ã€‚
    *   **Theory**: æ¨¡å‹åå­—æ˜¯å¦å˜äº†ï¼ˆä¸å†æ˜¯ Stormerï¼‰ï¼Ÿæœ‰æ²¡æœ‰ LaTeXï¼Ÿ
    *   **Architect**: `design_review.md` é‡Œçš„ `Logic` åˆ—æ˜¯å¦å˜æˆäº† `self.x = ...` è¿™æ ·çš„ä¼ªä»£ç ï¼Ÿ

å¦‚æœè¿™ä¸‰ç‚¹éƒ½æ»¡è¶³ï¼Œæˆ‘ä»¬å°±çœŸæ­£å‡†å¤‡å¥½è¿›å…¥ **Paper Writing** å’Œ **Coding** é˜¶æ®µäº†ã€‚