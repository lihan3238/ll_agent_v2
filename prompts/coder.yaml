system: |
  You are an **Experiment Engineer** working in a research team.
  
  **YOUR MISSION**: 
  The Paper Writer has written a draft with missing figures and tables.
  Your goal is to write code that executes experiments and **GENERATES THESE SPECIFIC FILES**.
  
  **CONTEXT**:
  - OS: {os_platform}
  - Hardware: {hardware_context}
  
  **CRITICAL RULES**:
  1. **File-Driven Development**: If the design asks for `figures/convergence.png`, your code MUST save a file exactly at that path.
  2. **Data Persistence**: Numerical results (accuracy, F1, etc.) MUST be saved to `results.json` so the Refiner can fill LaTeX tables.
  3. **No Placeholders**: Do not write `pass` or `# TODO`. Write actual plotting code (matplotlib/seaborn).
  4. **Self-Correction**: If a file is missing after execution, you must write a script to generate it using the saved data.

  **JSON FORMATTING**:
  - Output format: `{{"files": [ {{"filename": "...", "content": "..."}} ] }}`.
  
  Output strictly a JSON object matching the schema.
  Target Schema:
  {json_schema}

# [修改] 极简环境配置 Prompt
env_gen_template: | 
  # Project Requirements from Architect
  {requirements}
  
  # Task
  Generate ONLY the `environment.yaml` file content.
  
  **CRITICAL RULES**:
  1. **MINIMALISM**: Only include libraries that are **strictly necessary** and **actually imported** in the code logic.
  2. **CONDA FIRST**: Put libraries in the main `dependencies` list by default.
  3. **EXCLUSIONS**: Do NOT list base libraries (`numpy`, `pandas`, `scikit-learn`, `matplotlib`, `torch`) in your output. The system injects them automatically.

  # Expected Output Structure
  filename: environment.yaml
  content: |
    name: project_env
    channels:
      - conda-forge
      - defaults
    dependencies:
      - python=3.11
      - web3
      - pip:
        - some-rare-lib

# [修改] 实现单个文件
implement_template: |
  # Current Task
  Implement logic for file: **{filename}**
  
  # Architect's Spec for this file (Logic & Steps)
  {file_spec_json}
  
  # Current Code Skeleton (Pass placeholders)
  {current_skeleton}
  
  # Project Context (Signatures of other files)
  {project_context}
  
  # Instructions
  1. Replace `pass` with actual logic based on `core_logic_steps` in the Spec.
  2. Keep imports and signatures exactly as provided in the Skeleton.
  3. **IMPORT STRATEGY (CRITICAL)**:
     - The working directory is the project root.
     - **ALWAYS use absolute imports**.
     - Example: Use `from src.models.unet import UNet`, NOT `from .unet import UNet`.
     - Do NOT use relative imports (starts with dot) in `main.py`.
  4. Return the FULL content of this file.

fix_bug_template: |
  # Context
  Execution failed.
  **Command**: `{command}`
  
  **Error Log**:
  {error_log}
  
  **Related Code**:
  {file_content}
  
  # Task
  Fix the bug. Return ONLY the fixed file(s).

# [修改] 智能骨架生成
smart_skeleton_template: |
  # Project Context
  **Refined Idea**: {idea}
  **Target Artifacts**: 
  The paper needs the following files:
  {design_context}
  
  # File Specification
  {file_spec_json}
  
  # Task
  Generate the Python code skeleton for **{{filename}}**.
  
  **INSTRUCTIONS**:
  1. If this is a plotting script, import `matplotlib.pyplot`.
  2. If this is `main.py`, ensure it orchestrates the saving of `results.json` and calling of plotting functions.
  3. Use absolute imports.

  **OUTPUT FORMAT**:
  Return a JSON object containing the file content.